#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

vector<int> solution(vector<int> &A) {
    int N = A.size();
    vector<pair<int, int>> indexed_A(N);
    
    // Create a vector of pairs (height, index) to track the original index
    for (int i = 0; i < N; i++) {
        indexed_A[i] = {A[i], i};
    }
    
    // Sort based on the heights in non-decreasing order
    sort(indexed_A.begin(), indexed_A.end());
    
    // This will store the final heights of skyscrapers
    vector<int> B(N);
    
    // Assign unique heights starting from 1
    int current_height = 1;
    for (int i = 0; i < N; i++) {
        B[indexed_A[i].second] = current_height;
        current_height++;
    }
    
    return B;
}




vector<int> solution (vector<int> &A) {


      vector<int> v = A;
      int n = v.size();

      vector<int> ans(n);

      vector<pair<int,int>> vp;

      for (int i=0; i<n; i++) {
        vp.push_back({v[i], i});
      }

      sort(vp.rbegin(), vp.rend());

      int mx = vp[0].first;

      for (int i=0; i<n; i++) {
        int ind = vp[i].second;
        int el = vp[i].first;
        if (mx > el) mx = el;
        ans[ind] = mx;
        mx--;
      }
      return ans;

}











import java.util.Arrays;
import java.util.Comparator;

public class Solution {
    public int[] solution(int[] A) {
        int n = A.length;
        int[] ans = new int[n];
        int[][] vp = new int[n][2];

        // Pair values with their original indices
        for (int i = 0; i < n; i++) {
            vp[i][0] = A[i]; // value
            vp[i][1] = i;    // index
        }

        // Sort in descending order based on the value
        Arrays.sort(vp, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return Integer.compare(b[0], a[0]);
            }
        });

        int mx = vp[0][0]; // Start with the maximum value

        // Assign adjusted values based on the sorted pairs
        for (int i = 0; i < n; i++) {
            int el = vp[i][0]; // Current element
            int ind = vp[i][1]; // Original index
            if (mx > el) mx = el; // Update mx if the current element is smaller
            ans[ind] = mx; // Assign value to the original index
            mx--; // Decrease mx for the next iteration
        }

        return ans;
    }
}
