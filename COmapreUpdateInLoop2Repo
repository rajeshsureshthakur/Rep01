import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JFrogLatestFile {
    private static final long CHECK_INTERVAL_SECONDS = 60; // Check every 60 seconds

    public static void main(String[] args) {
        String baseUrl = "https://your-artifactory-url/artifactory";
        String token = "your-access-token";

        // Create and start thread for first repository
        Thread repo1Thread = new Thread(() -> 
            continuouslyCheckLatestFile(baseUrl, "repo1-key", token, "latest_file_repo1.csv")
        );
        repo1Thread.start();

        // Create and start thread for second repository
        Thread repo2Thread = new Thread(() -> 
            continuouslyCheckLatestFile(baseUrl, "repo2-key", token, "latest_file_repo2.csv")
        );
        repo2Thread.start();
    }

    public static void continuouslyCheckLatestFile(String repoUrl, String repoKey, String token, String csvFilePath) {
        while (true) {
            try {
                FileInfo latestFile = getLatestModifiedFile(repoUrl, repoKey, token);
                if (latestFile != null) {
                    compareAndUpdateCSV(latestFile, csvFilePath);
                }
                System.out.println("[" + repoKey + "] Waiting for " + CHECK_INTERVAL_SECONDS + " seconds before next check...");
                TimeUnit.SECONDS.sleep(CHECK_INTERVAL_SECONDS);
            } catch (IOException | InterruptedException e) {
                System.err.println("[" + repoKey + "] Error during check: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private static FileInfo getLatestModifiedFile(String repoUrl, String repoKey, String token) throws IOException, InterruptedException {
        String apiUrl = repoUrl + "/api/storage/" + repoKey + "?list&deep=1&listFolders=0";
        
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(apiUrl))
            .header("Authorization", "Bearer " + token)
            .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() != 200) {
            System.err.println("[" + repoKey + "] Error: HTTP status code " + response.statusCode());
            return null;
        }

        String responseBody = response.body();
        List<FileInfo> files = parseJsonResponse(responseBody);

        System.out.println("[" + repoKey + "] Number of files parsed: " + files.size());

        if (files.isEmpty()) {
            System.out.println("[" + repoKey + "] No files found in the repository.");
            return null;
        }

        return files.stream()
            .max((f1, f2) -> Long.compare(Long.parseLong(f1.lastModified), Long.parseLong(f2.lastModified)))
            .orElse(null);
    }

    private static void compareAndUpdateCSV(FileInfo latestFile, String csvFilePath) throws IOException {
        String savedFileName = "";
        long savedTimestamp = 0;
        if (Files.exists(Paths.get(csvFilePath))) {
            List<String> lines = Files.readAllLines(Paths.get(csvFilePath));
            if (!lines.isEmpty()) {
                String[] parts = lines.get(0).split(",");
                if (parts.length == 2) {
                    savedFileName = parts[0];
                    savedTimestamp = Long.parseLong(parts[1]);
                }
            }
        }

        long latestTimestamp = Long.parseLong(latestFile.lastModified);
        if (!savedFileName.equals(latestFile.name) || latestTimestamp > savedTimestamp) {
            String csvContent = latestFile.name + "," + latestFile.lastModified;
            Files.writeString(
                Paths.get(csvFilePath), 
                csvContent + System.lineSeparator(), 
                StandardOpenOption.CREATE, 
                StandardOpenOption.TRUNCATE_EXISTING
            );
            System.out.println("[" + csvFilePath + "] CSV updated with new latest file: " + latestFile.name + " (Timestamp: " + latestTimestamp + ")");
        } else {
            System.out.println("[" + csvFilePath + "] No update needed. Latest file is still: " + savedFileName + " (Timestamp: " + savedTimestamp + ")");
        }
    }

    private static List<FileInfo> parseJsonResponse(String json) {
        List<FileInfo> files = new ArrayList<>();
        try {
            Pattern childrenPattern = Pattern.compile("\"children\"\\s*:\\s*(\\[.*?\\])\\s*[,}]", Pattern.DOTALL);
            Matcher childrenMatcher = childrenPattern.matcher(json);
            
            if (childrenMatcher.find()) {
                String childrenJson = childrenMatcher.group(1);
                Pattern filePattern = Pattern.compile("\\{[^{}]*\\}");
                Matcher fileMatcher = filePattern.matcher(childrenJson);

                while (fileMatcher.find()) {
                    String fileJson = fileMatcher.group();
                    FileInfo fileInfo = parseFileInfo(fileJson);
                    if (fileInfo != null) {
                        files.add(fileInfo);
                    }
                }
            } else {
                System.out.println("Could not find 'children' array in JSON response");
            }
        } catch (Exception e) {
            System.err.println("Error parsing JSON response: " + e.getMessage());
            e.printStackTrace();
        }
        return files;
    }

    private static FileInfo parseFileInfo(String fileJson) {
        String name = extractValue(fileJson, "name");
        String lastModified = extractValue(fileJson, "lastModified");
        
        if (name != null && lastModified != null) {
            return new FileInfo(name, lastModified);
        }
        System.err.println("Could not parse file info from: " + fileJson);
        return null;
    }

    private static String extractValue(String json, String key) {
        Pattern pattern = Pattern.compile("\"" + key + "\"\\s*:\\s*(\"[^\"]*\"|\\d+)");
        Matcher matcher = pattern.matcher(json);
        if (matcher.find()) {
            String value = matcher.group(1);
            if (value.startsWith("\"") && value.endsWith("\"")) {
                return value.substring(1, value.length() - 1);
            }
            return value;
        }
        return null;
    }

    private static class FileInfo {
        String name;
        String lastModified;

        FileInfo(String name, String lastModified) {
            this.name = name;
            this.lastModified = lastModified;
        }
    }
}
